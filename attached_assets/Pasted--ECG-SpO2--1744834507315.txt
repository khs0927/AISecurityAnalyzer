# ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ë™ì„ í†µí•œ ê±´ê°• ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬í˜„

ì´ ë³´ê³ ì„œëŠ” ì‹¤ì œ ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ë™ì„ í†µí•œ ì‹¬ì „ë„(ECG), ì‚°ì†Œí¬í™”ë„(SpO2) ë“±ì„ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆëŠ” ê±´ê°• ëª¨ë‹ˆí„°ë§ ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì „ì²´ ì½”ë“œ êµ¬í˜„ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤. í”„ë¡ íŠ¸ì—”ë“œì™€ ë°±ì—”ë“œë¥¼ ëª¨ë‘ í¬í•¨í•˜ì—¬ ì™„ì „í•œ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ì‹œìŠ¤í…œ ê°œìš” ë° ì•„í‚¤í…ì²˜

ONE MORE LIFE ê±´ê°• ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì€ ìŠ¤ë§ˆíŠ¸ì›Œì¹˜(Apple Watch, Galaxy Watch ë“±)ì™€ ì—°ë™í•˜ì—¬ ì‚¬ìš©ìì˜ ì‹¤ì‹œê°„ ìƒì²´ ì‹ í˜¸ë¥¼ ì¸¡ì •, ë¶„ì„í•˜ê³  ìœ„í—˜ ìƒí™©ì„ ê°ì§€í•˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì…ë‹ˆë‹¤. ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ ì£¼ìš” êµ¬ì„± ìš”ì†Œë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥
- ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ì™€ ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ë° ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘
- ì‹¬ì „ë„(ECG), ì‚°ì†Œí¬í™”ë„(SpO2), ì‹¬ë°•ìˆ˜ ë“± í™œë ¥ì§•í›„ ëª¨ë‹ˆí„°ë§
- ì‹¤ì‹œê°„ ë°ì´í„° ë¶„ì„ ë° ìœ„í—˜ë„ í‰ê°€
- ê±´ê°• ë°ì´í„° ê¸°ë¡ ë° ì €ì¥
- ìœ„í—˜ ìƒí™© ê°ì§€ ì‹œ ì•Œë¦¼ ë° ê¸´ê¸‰ ì—°ë½ ê¸°ëŠ¥

### ê¸°ìˆ  ìŠ¤íƒ
- **í”„ë¡ íŠ¸ì—”ë“œ**: React, TypeScript, TailwindCSS
- **ë°±ì—”ë“œ**: Express.js, Node.js
- **ë°ì´í„°ë² ì´ìŠ¤**: PostgreSQL(Neon DB)
- **ORM**: Drizzle ORM
- **í†µì‹ **: Web Bluetooth API, WebSocket
- **ì°¨íŠ¸**: Chart.js, Recharts

## í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„

### ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ê²° ê´€ë¦¬ (SmartWatchContext.tsx)

ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ì™€ì˜ ì—°ê²° ìƒíƒœ ë° ë°ì´í„°ë¥¼ ì „ì—­ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•œ Context êµ¬í˜„ì…ë‹ˆë‹¤.

```tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { connectToSmartWatch, disconnectFromSmartWatch, listenToSmartWatchData } from '@/lib/bluetooth';

interface SmartWatchData {
  heartRate: number | null;
  oxygenLevel: number | null;
  ecgData: number[] | null;
  ppgData: number[] | null;
  temperature: number | null;
  batteryLevel: number | null;
  isRecording: boolean;
  lastUpdated: Date | null;
}

interface SmartWatchContextType {
  isConnected: boolean;
  isConnecting: boolean;
  deviceInfo: {
    name: string | null;
    id: string | null;
    model: string | null;
  };
  data: SmartWatchData;
  connect: () => Promise;
  disconnect: () => void;
  startRecording: () => void;
  stopRecording: () => void;
  error: string | null;
}

const initialData: SmartWatchData = {
  heartRate: null,
  oxygenLevel: null,
  ecgData: null,
  ppgData: null,
  temperature: null,
  batteryLevel: null,
  isRecording: false,
  lastUpdated: null,
};

const SmartWatchContext = createContext(undefined);

export const useSmartWatch = () => {
  const context = useContext(SmartWatchContext);
  if (!context) {
    throw new Error('useSmartWatch must be used within a SmartWatchProvider');
  }
  return context;
};

export const SmartWatchProvider = ({ children }: { children: ReactNode }) => {
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [deviceInfo, setDeviceInfo] = useState({
    name: null as string | null,
    id: null as string | null,
    model: null as string | null,
  });
  const [data, setData] = useState(initialData);
  const [error, setError] = useState(null);

  const handleDataUpdate = (newData: Partial) => {
    setData(prev => ({
      ...prev,
      ...newData,
      lastUpdated: new Date(),
    }));
  };

  const connect = async () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const deviceResult = await connectToSmartWatch();
      
      setDeviceInfo({
        name: deviceResult.name,
        id: deviceResult.id,
        model: deviceResult.model,
      });
      
      setIsConnected(true);
      
      // ë°ì´í„° ìˆ˜ì‹  ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      listenToSmartWatchData(handleDataUpdate);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setIsConnecting(false);
    }
  };

  // ê¸°íƒ€ í•¨ìˆ˜ ë° ì»¨í…ìŠ¤íŠ¸ í”„ë¡œë°”ì´ë” ìƒëµ...
};
```

### ë¸”ë£¨íˆ¬ìŠ¤ í†µì‹  ëª¨ë“ˆ (bluetooth.ts)

Web Bluetooth APIë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ì™€ í†µì‹ í•˜ëŠ” í•µì‹¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.

```typescript
import { SmartWatchData } from '@/contexts/SmartWatchContext';

interface BluetoothDevice {
  name: string;
  id: string;
  model: string;
}

let dataUpdateCallback: ((data: Partial) => void) | null = null;

export const connectToSmartWatch = async (): Promise => {
  try {
    if (!navigator.bluetooth) {
      throw new Error('ì´ ë¸Œë¼ìš°ì €ëŠ” Bluetooth ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    // ë¸”ë£¨íˆ¬ìŠ¤ ì¥ì¹˜ ìš”ì²­
    const device = await navigator.bluetooth.requestDevice({
      filters: [
        { services: ['heart_rate'] },
        { services: ['health_thermometer'] },
        { namePrefix: 'Apple Watch' },
        { namePrefix: 'Galaxy Watch' }
      ],
      optionalServices: [
        'battery_service',
        'device_information',
        'heart_rate',
        'health_thermometer',
        '6e400001-b5a3-f393-e0a9-e50e24dcca9e' // ECG ì„œë¹„ìŠ¤ UUID
      ]
    });

    const server = await device.gatt?.connect();
    if (!server) {
      throw new Error('GATT ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    // ì‹¬ë°•ìˆ˜, ì‚°ì†Œí¬í™”ë„, ì²´ì˜¨ ë“± ê° ì„œë¹„ìŠ¤ ì—°ê²°
    await connectHeartRateService(server);
    await connectOxygenLevelService(server);
    await connectTemperatureService(server);
    await connectBatteryService(server);

    return {
      name: device.name || 'ì•Œ ìˆ˜ ì—†ëŠ” ì¥ì¹˜',
      id: device.id,
      model: 'ìŠ¤ë§ˆíŠ¸ì›Œì¹˜'
    };
  } catch (err) {
    console.error('ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ê²° ì˜¤ë¥˜:', err);
    throw err;
  }
};

export const listenToSmartWatchData = (callback: (data: Partial) => void) => {
  dataUpdateCallback = callback;
};

// ì‹¬ë°•ìˆ˜ ì„œë¹„ìŠ¤ ì—°ê²° ë° ëª¨ë‹ˆí„°ë§
const connectHeartRateService = async (server: BluetoothRemoteGATTServer) => {
  try {
    const service = await server.getPrimaryService('heart_rate');
    const characteristic = await service.getCharacteristic('heart_rate_measurement');
    
    // ì‹¬ë°•ìˆ˜ ë°ì´í„° ë³€ê²½ ëª¨ë‹ˆí„°ë§
    await characteristic.startNotifications();
    characteristic.addEventListener('characteristicvaluechanged', handleHeartRateData);
  } catch (err) {
    console.error('ì‹¬ë°•ìˆ˜ ì„œë¹„ìŠ¤ ì—°ê²° ì˜¤ë¥˜:', err);
    throw err;
  }
};

// ì‹¬ë°•ìˆ˜ ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜
const handleHeartRateData = (event: Event) => {
  const characteristic = event.target as BluetoothRemoteGATTCharacteristic;
  const value = characteristic.value;
  if (!value) return;
  
  // ì‹¬ë°•ìˆ˜ ë°ì´í„° íŒŒì‹±
  const flags = value.getUint8(0);
  const heartRateFormat = flags & 0x01; // 0: UINT8, 1: UINT16
  
  let heartRate: number;
  if (heartRateFormat === 0) {
    heartRate = value.getUint8(1);
  } else {
    heartRate = value.getUint16(1, true);
  }
  
  // ECG ë°ì´í„°ê°€ í¬í•¨ë˜ì–´ ìˆëŠ” ê²½ìš° ì²˜ë¦¬
  let ecgData: number[] | null = null;
  if (value.byteLength > (heartRateFormat === 0 ? 2 : 3)) {
    ecgData = [];
    for (let i = heartRateFormat === 0 ? 2 : 3; i  {
  const { data, isConnected } = useSmartWatch();
  const [ecgData, setEcgData] = useState([]);
  const [ecgStatus, setEcgStatus] = useState('checking');
  const [isRecording, setIsRecording] = useState(false);
  const [recordDuration, setRecordDuration] = useState(0);
  const recordingTimerRef = useRef(null);
  const { toast } = useToast();
  
  // ì‹¬ì „ë„ ë°ì´í„° ê°±ì‹ 
  useEffect(() => {
    if (data.ecgData) {
      setEcgData(prevData => {
        // ìµœëŒ€ 300ê°œ ë°ì´í„° í¬ì¸íŠ¸ ìœ ì§€ (ì•½ 30ì´ˆ)
        const newData = [...prevData, ...data.ecgData];
        return newData.length > 300 ? newData.slice(-300) : newData;
      });
      
      // ìƒíƒœ ë¶„ì„
      if (ecgData.length >= 100) {
        const status = analyzeECG(ecgData);
        setEcgStatus(status);
        
        // ìœ„í—˜ ìƒíƒœì¼ ê²½ìš° ì•Œë¦¼
        if (status === 'critical' && !isRecording) {
          toast({
            title: 'ì‹¬ì „ë„ ì´ìƒ ê°ì§€',
            description: 'ì‹¬ê°í•œ ì‹¬ì „ë„ ì´ìƒì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ì¸¡ì •ì„ ê¸°ë¡í•˜ì„¸ìš”.',
            variant: 'destructive',
          });
        }
      }
    }
  }, [data.ecgData]);
  
  // ë…¹í™” íƒ€ì´ë¨¸
  useEffect(() => {
    if (isRecording) {
      recordingTimerRef.current = window.setInterval(() => {
        setRecordDuration(prev => prev + 1);
      }, 1000);
    } else {
      if (recordingTimerRef.current) {
        window.clearInterval(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }
      setRecordDuration(0);
    }
    
    return () => {
      if (recordingTimerRef.current) {
        window.clearInterval(recordingTimerRef.current);
      }
    };
  }, [isRecording]);
  
  const startRecording = () => {
    setIsRecording(true);
    toast({
      title: 'ì‹¬ì „ë„ ê¸°ë¡ ì‹œì‘',
      description: 'ì‹¬ì „ë„ ê¸°ë¡ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì¸¡ì • ì¤‘ ì›€ì§ì´ì§€ ë§ˆì„¸ìš”.',
    });
  };
  
  const stopRecording = async () => {
    setIsRecording(false);
    
    // ì„œë²„ì— ë°ì´í„° ì €ì¥
    try {
      await saveEcgRecording({
        data: ecgData,
        duration: recordDuration,
        status: ecgStatus,
        timestamp: new Date().toISOString(),
      });
      
      toast({
        title: 'ì‹¬ì „ë„ ê¸°ë¡ ì™„ë£Œ',
        description: `${recordDuration}ì´ˆ ë™ì•ˆì˜ ì‹¬ì „ë„ ê¸°ë¡ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        variant: 'success',
      });
    } catch (err) {
      toast({
        title: 'ê¸°ë¡ ì €ì¥ ì‹¤íŒ¨',
        description: 'ì‹¬ì „ë„ ê¸°ë¡ì„ ì €ì¥í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        variant: 'destructive',
      });
    }
  };
  
  // ì°¨íŠ¸ ë°ì´í„° ë° ë Œë”ë§ ì½”ë“œ...
};
```

### ì‚°ì†Œí¬í™”ë„(PPG) ëª¨ë‹ˆí„°ë§ ì»´í¬ë„ŒíŠ¸ (PPGMonitor.tsx)

í˜ˆì¤‘ ì‚°ì†Œí¬í™”ë„ ë°ì´í„°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì‹œê°í™”í•˜ê³  ë¶„ì„í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.

```tsx
import React, { useEffect, useState } from 'react';
import { useSmartWatch } from '@/contexts/SmartWatchContext';
import { Card } from '@/components/ui/card';
import { Activity, Check, AlertTriangle, AlertCircle } from 'lucide-react';
import { Line } from 'react-chartjs-2';
import { useToast } from '@/lib/use-toast';
import { analyzePPG } from '@/lib/ppgAnalyzer';

type PPGStatus = 'normal' | 'warning' | 'critical' | 'checking';

const PPGMonitor = () => {
  const { data, isConnected } = useSmartWatch();
  const [ppgData, setPpgData] = useState([]);
  const [ppgStatus, setPpgStatus] = useState('checking');
  const { toast } = useToast();
  
  // ì‚°ì†Œí¬í™”ë„ ë°ì´í„° ê°±ì‹ 
  useEffect(() => {
    if (data.ppgData) {
      setPpgData(prevData => {
        const newData = [...prevData, ...data.ppgData];
        return newData.length > 300 ? newData.slice(-300) : newData;
      });
      
      // ìƒíƒœ ë¶„ì„
      if (ppgData.length >= 100) {
        const status = analyzePPG(ppgData, data.oxygenLevel || 0);
        setPpgStatus(status);
        
        // ìœ„í—˜ ìƒíƒœì¼ ê²½ìš° ì•Œë¦¼
        if (status === 'critical') {
          toast({
            title: 'ì‚°ì†Œí¬í™”ë„ ìœ„í—˜',
            description: 'ì‚°ì†Œí¬í™”ë„ê°€ ë§¤ìš° ë‚®ìŠµë‹ˆë‹¤. ì¦‰ì‹œ ì˜ë£Œì§„ì—ê²Œ ì—°ë½í•˜ì„¸ìš”.',
            variant: 'destructive',
          });
        }
      }
    }
  }, [data.ppgData, data.oxygenLevel]);
  
  // ìƒíƒœ í‘œì‹œ ë° ì°¨íŠ¸ ë Œë”ë§ ì½”ë“œ...
};
```

### ë©”ì¸ ëª¨ë‹ˆí„°ë§ í˜ì´ì§€ (VitalSignsMonitoring.tsx)

ì—¬ëŸ¬ ê±´ê°• ì§€í‘œë¥¼ í†µí•©ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ë©”ì¸ í˜ì´ì§€ì…ë‹ˆë‹¤.

```tsx
import React, { useState, useEffect } from 'react';
import { useSmartWatch } from '@/contexts/SmartWatchContext';
import SmartWatchConnector from '@/components/smartwatch/SmartWatchConnector';
import ECGMonitor from '@/components/monitoring/ECGMonitor';
import PPGMonitor from '@/components/monitoring/PPGMonitor';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Activity, Heart, Thermometer, Clock, Phone } from 'lucide-react';
import ModeSwitcher from '@/components/ModeSwitcher';
import { useToast } from '@/lib/use-toast';
import { analyzeHealthData } from '@/lib/api';

interface AiAnalysisResult {
  timestamp: string;
  riskScore: number;
  summary: string;
  recommendation: string;
}

const VitalSignsMonitoring = () => {
  const { data, isConnected } = useSmartWatch();
  const [showEmergencyCall, setShowEmergencyCall] = useState(false);
  const [aiAnalysisResult, setAiAnalysisResult] = useState(null);
  const { toast } = useToast();
  
  // ì¼ì • ì‹œê°„ë§ˆë‹¤ AI ë¶„ì„ ì‹¤í–‰
  useEffect(() => {
    if (!isConnected) return;
    
    const interval = setInterval(async () => {
      await performAIAnalysis();
    }, 60000); // 1ë¶„ë§ˆë‹¤ ë¶„ì„
    
    return () => clearInterval(interval);
  }, [isConnected, data]);
  
  // AI ë¶„ì„ ì‹¤í–‰
  const performAIAnalysis = async () => {
    try {
      const result = await analyzeHealthData({
        heartRate: data.heartRate,
        oxygenLevel: data.oxygenLevel,
        temperature: data.temperature,
        ecgData: data.ecgData?.slice(-100),
        ppgData: data.ppgData?.slice(-100),
      });
      
      setAiAnalysisResult({
        timestamp: new Date().toISOString(),
        riskScore: result.riskScore,
        summary: result.summary,
        recommendation: result.recommendation,
      });
      
      // ìœ„í—˜ë„ê°€ ë†’ìœ¼ë©´ ì•Œë¦¼
      if (result.riskScore > 70) {
        toast({
          title: 'ê±´ê°• ìœ„í—˜ ê°ì§€',
          description: result.summary,
          variant: 'destructive',
        });
        setShowEmergencyCall(true);
      }
    } catch (err) {
      console.error('AI ë¶„ì„ ì˜¤ë¥˜:', err);
    }
  };
  
  const handleEmergencyCall = () => {
    window.location.href = 'tel:119';
  };
  
  return (
    
      
        ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
        ì‹¬ì „ë„, ì‚°ì†Œí¬í™”ë„ ë“± ì‹¤ì‹œê°„ ê±´ê°• ë°ì´í„°ë¥¼ ëª¨ë‹ˆí„°ë§í•©ë‹ˆë‹¤.
      
      
      
        
      
      
      
        
        
        
        {/* ì¶”ê°€ ê±´ê°• ë°ì´í„° */}
        
          
            ê¸°íƒ€ ê±´ê°• ë°ì´í„°
          
          
          
            
              
                
                ì‹¬ë°•ìˆ˜
              
              {data.heartRate || '--'}
              bpm
            
            
            
              
                
                ì²´ì˜¨
              
              {data.temperature?.toFixed(1) || '--'}
              Â°C
            
            
            
              
                
                ì¸¡ì • ì‹œê°„
              
              
                {data.lastUpdated ? new Date(data.lastUpdated).toLocaleTimeString() : '--:--'}
              
            
          
        
        
        {/* AI ë¶„ì„ ê²°ê³¼ ë° ì‘ê¸‰ ì „í™” UI ìƒëµ... */}
      
    
  );
};
```

## ë°±ì—”ë“œ êµ¬í˜„

### ì„œë²„ ë©”ì¸ íŒŒì¼ (server/index.ts)

Express ì„œë²„ì™€ WebSocket ì—°ê²°ì„ ì„¤ì •í•©ë‹ˆë‹¤.

```typescript
import express from 'express';
import session from 'express-session';
import { createClient } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-serverless';
import connectPgSimple from 'connect-pg-simple';
import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import { WebSocketServer } from 'ws';
import path from 'path';
import { fileURLToPath } from 'url';
import { config } from './config';
import { userRoutes } from './routes/userRoutes';
import { healthDataRoutes } from './routes/healthDataRoutes';
import { smartwatchRoutes } from './routes/smartwatchRoutes';
import { errorHandler } from './middleware/errorMiddleware';
import { User } from '../shared/schema';
import { userService } from './services/userService';

// ì´ˆê¸°í™” ì½”ë“œ ìƒëµ...

// ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
const sql = createClient({
  connectionString: config.databaseUrl,
});
await sql.connect();
export const db = drizzle(sql);

// Express ì•± ì„¤ì •
const app = express();
const PgSession = connectPgSimple(session);

// ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ì„¸ì…˜ ë° ì¸ì¦ ì„¤ì •
app.use(session({
  store: new PgSession({
    pool: sql,
    tableName: 'session',
  }),
  secret: config.sessionSecret,
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30ì¼
    secure: isProduction,
  },
}));

app.use(passport.initialize());
app.use(passport.session());

// Passport ì „ëµ ì„¤ì •
passport.use(new LocalStrategy(async (username, password, done) => {
  try {
    const user = await userService.verifyUser(username, password);
    if (!user) return done(null, false);
    return done(null, user);
  } catch (err) {
    return done(err);
  }
}));

// API ë¼ìš°íŠ¸
app.use('/api/users', userRoutes);
app.use('/api/health-data', healthDataRoutes);
app.use('/api/smartwatch', smartwatchRoutes);

// ì •ì  íŒŒì¼ ì œê³µ (í”„ë¡œë•ì…˜ í™˜ê²½)
if (isProduction) {
  app.use(express.static(path.join(__dirname, '../client')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/index.html'));
  });
}

// ì—ëŸ¬ í•¸ë“¤ëŸ¬
app.use(errorHandler);

// HTTP ì„œë²„ ì‹œì‘
const server = app.listen(PORT, () => {
  console.log(`ğŸš€ ì„œë²„ê°€ http://localhost:${PORT}ì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.`);
});

// WebSocket ì„œë²„ ì„¤ì •
const wss = new WebSocketServer({ server });

wss.on('connection', (ws) => {
  console.log('WebSocket í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.');
  
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message.toString());
      
      // ì‹¤ì‹œê°„ ê±´ê°• ë°ì´í„° ì²˜ë¦¬
      if (data.type === 'health_data') {
        // ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        wss.clients.forEach((client) => {
          if (client !== ws && client.readyState === ws.OPEN) {
            client.send(JSON.stringify({
              type: 'health_data_update',
              data: data.data,
            }));
          }
        });
      }
    } catch (err) {
      console.error('WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:', err);
    }
  });
});
```

### ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ë¼ìš°íŠ¸ (smartwatchRoutes.ts)

ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ë°ì´í„° ì²˜ë¦¬ë¥¼ ìœ„í•œ API ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

```typescript
import express from 'express';
import { smartwatchController } from '../controllers/smartwatchController';
import { authMiddleware } from '../middleware/auth';

const router = express.Router();

// ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ë°ì´í„° ìˆ˜ì‹ 
router.post('/data', authMiddleware, smartwatchController.receiveData);

// ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ECG ë°ì´í„° ì €ì¥
router.post('/ecg', authMiddleware, smartwatchController.saveEcgRecording);

// ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ê¸°ë¡ ì¡°íšŒ
router.get('/records', authMiddleware, smartwatchController.getRecords);

// íŠ¹ì • ê¸°ë¡ ìƒì„¸ ì¡°íšŒ
router.get('/records/:id', authMiddleware, smartwatchController.getRecordById);

// ê±´ê°• ë°ì´í„° ë¶„ì„
router.post('/analyze', authMiddleware, smartwatchController.analyzeHealthData);

export const smartwatchRoutes = router;
```

### ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì»¨íŠ¸ë¡¤ëŸ¬ (smartwatchController.ts)

ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ê³  ë¶„ì„í•˜ëŠ” í•µì‹¬ ë¡œì§ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

```typescript
import { Request, Response, NextFunction } from 'express';
import { smartwatchService } from '../services/smartwatchService';
import { healthDataService } from '../services/healthDataService';
import { analyzeECGData, analyzePPGData } from '../utils/healthDataAnalyzer';

export const smartwatchController = {
  // ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ë°ì´í„° ìˆ˜ì‹ 
  async receiveData(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.' });
      }
      
      const healthData = req.body;
      
      // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
      if (!healthData) {
        return res.status(400).json({ error: 'ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ì…ë‹ˆë‹¤.' });
      }
      
      // ê±´ê°• ë°ì´í„° ì €ì¥
      const savedData = await healthDataService.saveHealthData({
        userId,
        ...healthData,
      });
      
      res.status(201).json(savedData);
    } catch (err) {
      next(err);
    }
  },
  
  // ECG ê¸°ë¡ ì €ì¥
  async saveEcgRecording(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.' });
      }
      
      const { data, duration, status, timestamp } = req.body;
      
      // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
      if (!data || !Array.isArray(data)) {
        return res.status(400).json({ error: 'ìœ íš¨í•˜ì§€ ì•Šì€ ECG ë°ì´í„°ì…ë‹ˆë‹¤.' });
      }
      
      // ECG ë¶„ì„ ìˆ˜í–‰
      const analysis = await analyzeECGData(data);
      
      // ECG ê¸°ë¡ ì €ì¥
      const savedRecording = await smartwatchService.saveEcgRecording({
        userId,
        data,
        duration,
        abnormalities: analysis.abnormalities,
        analysis: {
          status,
          details: analysis.details,
          recommendations: analysis.recommendations,
        },
      });
      
      // ì´ìƒì´ ê°ì§€ë˜ë©´ ì•Œë¦¼ ìƒì„±
      if (analysis.abnormalities && analysis.abnormalities.length > 0) {
        await smartwatchService.createAlert({
          userId,
          alertType: status === 'critical' ? 'risk' : 'warning',
          message: `ECG ì´ìƒì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${analysis.abnormalities.join(', ')}`,
          ecgRecordingId: savedRecording.id,
        });
      }
      
      res.status(201).json(savedRecording);
    } catch (err) {
      next(err);
    }
  },
  
  // ê±´ê°• ë°ì´í„° ë¶„ì„
  async analyzeHealthData(req: Request, res: Response, next: NextFunction) {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'ì¸ì¦ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.' });
      }
      
      const { heartRate, oxygenLevel, temperature, ecgData, ppgData } = req.body;
      
      // ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const user = await smartwatchService.getUserInfo(userId);
      
      // ECG ë° PPG ë°ì´í„° ë¶„ì„
      const ecgAnalysis = ecgData ? await analyzeECGData(ecgData) : null;
      const ppgAnalysis = ppgData ? await analyzePPGData(ppgData, oxygenLevel) : null;
      
      // ì¢…í•© ìœ„í—˜ë„ ë¶„ì„
      const analysis = await smartwatchService.performComprehensiveAnalysis({
        userId,
        user,
        heartRate,
        oxygenLevel,
        temperature,
        ecgAnalysis,
        ppgAnalysis,
      });
      
      // ë¶„ì„ ê²°ê³¼ ì €ì¥
      await smartwatchService.saveAnalysisResult(userId, analysis);
      
      // ìœ„í—˜ë„ê°€ ë†’ìœ¼ë©´ ì•Œë¦¼ ìƒì„±
      if (analysis.riskScore > 70) {
        await smartwatchService.createAlert({
          userId,
          alertType: 'risk',
          message: `ë†’ì€ ìœ„í—˜ë„ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${analysis.summary}`,
        });
      }
      
      res.json(analysis);
    } catch (err) {
      next(err);
    }
  },
  
  // ê¸°ë¡ ì¡°íšŒ í•¨ìˆ˜ë“¤ ìƒëµ...
};
```

### ê±´ê°• ë°ì´í„° ë¶„ì„ ìœ í‹¸ë¦¬í‹° (healthDataAnalyzer.ts)

ECG ë° PPG ë°ì´í„°ë¥¼ ë¶„ì„í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

```typescript
// ECG ë°ì´í„° ë¶„ì„
export const analyzeECGData = async (ecgData: number[]) => {
  try {
    // RR ê°„ê²© ê³„ì‚° (R-peak ì‚¬ì´ì˜ ê°„ê²©)
    const rPeaks = findRPeaks(ecgData);
    const rrIntervals = calculateRRIntervals(rPeaks);
    
    // ë¶€ì •ë§¥ ê°ì§€
    const hasArrhythmia = detectArrhythmia(rrIntervals);
    
    // ST ë¶„ì ˆ ë³€í™” ê°ì§€ (í—ˆí˜ˆ/ì‹¬ê·¼ê²½ìƒ‰ ê´€ë ¨)
    const stSegmentChange = detectSTSegmentChange(ecgData);
    
    // ì´ìƒ ìœ í˜• ëª©ë¡
    const abnormalities = [];
    let status = 'normal';
    
    if (hasArrhythmia) {
      abnormalities.push('ë¶€ì •ë§¥');
      status = 'warning';
    }
    
    if (stSegmentChange > 0.2) {
      abnormalities.push('ST ë¶„ì ˆ ìƒìŠ¹');
      status = 'critical';
    } else if (stSegmentChange  threshold && ecgData[i] > ecgData[i-1] && ecgData[i] > ecgData[i+1]) {
      rPeaks.push(i);
    }
  }
  
  return rPeaks;
}

// ê¸°íƒ€ ë¶„ì„ í•¨ìˆ˜ë“¤ ìƒëµ...
```

### ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì„œë¹„ìŠ¤ (smartwatchService.ts)

ê±´ê°• ë°ì´í„° ì²˜ë¦¬ì™€ ìœ„í—˜ë„ ë¶„ì„ì„ ë‹´ë‹¹í•˜ëŠ” ì„œë¹„ìŠ¤ ê³„ì¸µì„ êµ¬í˜„í•©ë‹ˆë‹¤.

```typescript
import { db } from '../index';
import { 
  ecgRecordings, 
  alerts, 
  aiAnalyses, 
  users,
  healthData,
} from '../../shared/schema';
import { eq } from 'drizzle-orm';

export const smartwatchService = {
  // ECG ê¸°ë¡ ì €ì¥
  async saveEcgRecording(data) {
    const [result] = await db.insert(ecgRecordings).values(data).returning();
    return result;
  },
  
  // ì•Œë¦¼ ìƒì„±
  async createAlert(data) {
    const [result] = await db.insert(alerts).values(data).returning();
    return result;
  },
  
  // ì¢…í•© ìœ„í—˜ë„ ë¶„ì„
  async performComprehensiveAnalysis(input) {
    const { 
      userId, 
      user, 
      heartRate, 
      oxygenLevel, 
      temperature, 
      ecgAnalysis, 
      ppgAnalysis 
    } = input;
    
    // ê¸°ë³¸ ìœ„í—˜ë„ ì ìˆ˜
    let riskScore = 0;
    const factors = [];
    
    // ì‹¬ë°•ìˆ˜ ë¶„ì„
    if (heartRate !== null && heartRate !== undefined) {
      // ë‚˜ì´ë³„ ì •ìƒ ì‹¬ë°•ìˆ˜ ë²”ìœ„ ê³„ì‚°
      const age = user.age || 30;
      const maxNormalHeartRate = 220 - age;
      const minNormalHeartRate = 60;
      
      if (heartRate > maxNormalHeartRate * 0.85) {
        riskScore += 15;
        factors.push('ì‹¬ë°•ìˆ˜ ìƒìŠ¹');
      } else if (heartRate = 70) {
      summary = `ì‹¬ê°í•œ ê±´ê°• ìœ„í—˜ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${factors.join(', ')}`;
      recommendation = 'ì¦‰ì‹œ ì˜ë£Œì§„ì—ê²Œ ì—°ë½í•˜ê±°ë‚˜ ì‘ê¸‰ì‹¤ì„ ë°©ë¬¸í•˜ì„¸ìš”.';
    } else if (riskScore >= 40) {
      summary = `ê±´ê°• ì´ìƒì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${factors.join(', ')}`;
      recommendation = 'ì˜ì‚¬ì™€ ìƒë‹´í•˜ê³  ìƒíƒœë¥¼ ê³„ì† ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”.';
    } else {
      summary = factors.length ? `ê²½ë¯¸í•œ ì´ìƒì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤: ${factors.join(', ')}` : 'ì •ìƒ ë²”ìœ„ ë‚´ì˜ ê±´ê°• ìƒíƒœì…ë‹ˆë‹¤.';
      recommendation = 'ì •ê¸°ì ìœ¼ë¡œ ê±´ê°•ì„ ëª¨ë‹ˆí„°ë§í•˜ì„¸ìš”.';
    }
    
    return {
      riskScore,
      factors,
      summary,
      recommendation,
      timestamp: new Date().toISOString(),
    };
  },
  
  // ê¸°íƒ€ ì„œë¹„ìŠ¤ í•¨ìˆ˜ë“¤...
};
```

## ì—°ë™ ë° í†µì‹  ëª¨ë“ˆ

### API í´ë¼ì´ì–¸íŠ¸ (api.ts)

í”„ë¡ íŠ¸ì—”ë“œì™€ ë°±ì—”ë“œ ê°„ì˜ í†µì‹ ì„ ë‹´ë‹¹í•˜ëŠ” API í´ë¼ì´ì–¸íŠ¸ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

```typescript
// ê¸°ë³¸ API ìš”ì²­ í•¨ìˆ˜
async function request(url: string, options?: RequestInit): Promise {
  try {
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include', // ì¿ í‚¤ í¬í•¨
      ...options,
    });
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || `API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
    }
    
    return await response.json();
  } catch (err) {
    console.error('API ìš”ì²­ ì˜¤ë¥˜:', err);
    throw err;
  }
}

// ê±´ê°• ë°ì´í„° ì €ì¥
export async function saveHealthData(data: any) {
  return request('/api/health-data', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

// ECG ê¸°ë¡ ì €ì¥
export async function saveEcgRecording(data: any) {
  return request('/api/smartwatch/ecg', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

// ê±´ê°• ë°ì´í„° ë¶„ì„
export async function analyzeHealthData(data: any) {
  return request('/api/smartwatch/analyze', {
    method: 'POST',
    body: JSON.stringify(data),
  });
}

// WebSocket ì—°ê²°
export function connectWebSocket(
  onMessage: (data: any) => void,
  onOpen?: () => void,
  onClose?: () => void,
  onError?: (error: Event) => void
) {
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const wsUrl = `${protocol}//${window.location.host}/ws`;
  
  const socket = new WebSocket(wsUrl);
  
  socket.onopen = () => {
    console.log('WebSocket ì—°ê²° ì„±ê³µ');
    if (onOpen) onOpen();
  };
  
  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      onMessage(data);
    } catch (err) {
      console.error('WebSocket ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', err);
    }
  };
  
  // ê¸°íƒ€ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬...
  
  return {
    send: (data: any) => {
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(data));
      }
    },
    close: () => {
      socket.close();
    },
  };
}
```

## ê²°ë¡ 

ì´ ë³´ê³ ì„œì—ì„œëŠ” ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ë™ì„ í†µí•œ ì‹¬ì „ë„, ì‚°ì†Œí¬í™”ë„ ë“±ì„ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆëŠ” ê±´ê°• ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ ì „ì²´ ì½”ë“œ êµ¬í˜„ì„ ì œì‹œí–ˆìŠµë‹ˆë‹¤. ì£¼ìš” êµ¬í˜„ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

1. Web Bluetooth APIë¥¼ í™œìš©í•œ ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ì—°ê²° ë° ë°ì´í„° ìˆ˜ì§‘ ê¸°ëŠ¥
2. ì‹¤ì‹œê°„ ì‹¬ì „ë„(ECG) ë° ì‚°ì†Œí¬í™”ë„(PPG) ëª¨ë‹ˆí„°ë§ ë° ì‹œê°í™”
3. ê±´ê°• ë°ì´í„° ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ì„ í†µí•œ ì´ìƒ ì§•í›„ ê°ì§€
4. ìœ„í—˜ ìƒí™© ê°ì§€ ì‹œ ì•Œë¦¼ ë° ì‘ê¸‰ ì—°ë½ ê¸°ëŠ¥
5. ê±´ê°• ë°ì´í„° ì €ì¥ ë° ë¶„ì„ì„ ìœ„í•œ ë°±ì—”ë“œ API

ì´ ì‹œìŠ¤í…œì€ ì‚¬ìš©ìì˜ ê±´ê°• ìƒíƒœë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ê³ , ì ì¬ì ì¸ ê±´ê°• ë¬¸ì œë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ì—¬ ì ì ˆí•œ ì˜ë£Œ ì¡°ì¹˜ë¥¼ ì·¨í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤. ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ì™€ ê°™ì€ ì›¨ì–´ëŸ¬ë¸” ê¸°ê¸°ì˜ ëŒ€ì¤‘í™”ë¡œ ì´ëŸ¬í•œ ê±´ê°• ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì€ ì•ìœ¼ë¡œ ë”ìš± ì¤‘ìš”í•´ì§ˆ ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.

ì‹¤ì œ ì˜ë£Œ ëª©ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ” ë” ì •ë°€í•œ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ê³¼ ì˜ë£Œ ì „ë¬¸ê°€ì˜ ê²€ì¦ì´ í•„ìš”í•˜ë©°, ë‹¤ì–‘í•œ ìŠ¤ë§ˆíŠ¸ì›Œì¹˜ ê¸°ê¸°ì˜ í˜¸í™˜ì„±ì„ ê³ ë ¤í•œ ì¶”ê°€ ê°œë°œì´ í•„ìš”í•©ë‹ˆë‹¤.

Citations:
[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/66747649-0ac1-4184-9399-d8909e70d21f/package.json
[2] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/f56057c4-954d-4587-bccc-d0052ba8f74d/README.md
[3] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/a0ff43b4-461a-4fd4-8cd2-412388cadc07/schema.ts
[4] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/f5119395-45ff-4576-bb5c-15d8571cd555/index.css
[5] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/63d038c8-fb5d-4638-90c8-ab1e143bc213/VitalSignsMonitoring.tsx
[6] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/39238153-0907-4d03-a19b-0fe8ab5d5685/use-toast.ts
[7] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/1686f176-86d2-4044-b7ba-b0d57be49db0/ModeSwitcher.tsx
[8] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/4f6c72ac-237e-479c-a930-719ac58d9a10/AppLayout.tsx
[9] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/53686762/3a3e75b2-3616-4665-8147-3af42cdc9f84/BottomNavigation.tsx

---
Perplexityë¡œë¶€í„°ì˜ ë‹µë³€: pplx.ai/share